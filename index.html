<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>é­”æ³•æ˜Ÿå°˜ï¼šè‹±è¯­å…¨èƒ½å¤§å¸ˆ (ä¿®å¤ç‰ˆ)</title>
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at bottom center, #562b7c 0%, #2b1055 50%, #0f0524 100%);
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Microsoft YaHei', sans-serif;
            user-select: none;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { display: none; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
        }
        
        /* é¡¶éƒ¨ç›®æ ‡æç¤º */
        #target-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            text-align: center;
            color: #fff; font-size: 24px; font-weight: bold;
            border-bottom: 2px solid rgba(255,255,255,0.2);
            display: none;
        }
        #current-target-text { color: #ffd700; font-size: 36px; margin-left: 10px; vertical-align: middle;}

        /* åˆ†æ•°ä¸è¿›åº¦ */
        #score-board {
            position: absolute; top: 90px; left: 20px;
            font-size: 26px; color: #fff; text-shadow: 2px 2px 4px #000;
        }
        #score-val { color: #ffd700; font-size: 36px; font-weight: bold; }

        #top-right-panel {
            position: absolute; top: 90px; right: 20px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
        }
        #progress-board { font-size: 22px; color: #0ff; text-shadow: 1px 1px 2px #000; font-weight: bold; }
        
        .control-btn {
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white; font-size: 16px;
            padding: 6px 16px; border-radius: 30px;
            cursor: pointer; transition: 0.2s;
            width: 130px; text-align: center; margin-bottom: 5px;
            backdrop-filter: blur(5px);
        }
        #pause-btn { background: rgba(255, 255, 255, 0.2); }
        #home-btn { background: rgba(255, 80, 80, 0.3); border-color: rgba(255, 100, 100, 0.6); }
        /* æµ‹è¯•æŒ‰é’® */
        #debug-btn { background: rgba(255, 215, 0, 0.3); border-color: rgba(255, 215, 0, 0.8); color: #ffd700; font-weight: bold;}
        
        .control-btn:hover { transform: scale(1.05); filter: brightness(1.2); }

        /* èœå•å±‚ */
        #menu-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; 
            flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 40;
            backdrop-filter: blur(10px);
        }
        .menu-title { font-size: 50px; color: #ffd700; margin-bottom: 40px; text-shadow: 0 0 20px #f0f; font-weight: bold; }
        .mode-btn {
            pointer-events: auto;
            background: linear-gradient(45deg, #4b2d7f, #7597de);
            border: 2px solid #fff;
            color: white; font-size: 28px; padding: 20px 40px; margin: 15px;
            border-radius: 50px; cursor: pointer; width: 420px; text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .mode-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px #0ff; background: linear-gradient(45deg, #6a4c9c, #95b7fe); }
        .mode-desc { display: block; font-size: 16px; color: #ddd; margin-top: 5px; font-weight: normal;}

        /* é®ç½©å±‚ (æ•™å­¦/å€’è®¡æ—¶/èƒœåˆ©) */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; 
            flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 20;
            backdrop-filter: blur(8px);
        }
        #overlay-title { font-size: 30px; color: #aaa; margin-bottom: 20px; letter-spacing: 2px;}
        #overlay-content { font-size: 100px; font-weight: bold; color: #ffd700; text-shadow: 0 0 40px #f0f; text-align: center; margin-bottom: 20px;}
        #overlay-sub { font-size: 30px; margin-top: 20px; color: #0ff; border: 2px dashed #0ff; padding: 10px 30px; border-radius: 50px; animation: pulse 1s infinite alternate; }
        @keyframes pulse { from { transform: scale(1); opacity: 0.8; } to { transform: scale(1.05); opacity: 1; } }
        #overlay-countdown { font-size: 150px; font-weight: bold; color: #fff; margin-top: 50px; display: none; }
        
        /* èƒœåˆ©é¡µé¢ä¸“å±æ ·å¼ */
        .victory-title { font-size: 120px !important; color: #0f0 !important; text-shadow: 0 0 30px #fff, 0 0 60px #0f0 !important; animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .victory-sub { border: none !important; color: #fff !important; font-size: 40px !important; background: rgba(255,255,255,0.2); cursor: pointer; transition: 0.3s; }
        .victory-sub:hover { background: rgba(255,255,255,0.4); transform: scale(1.1); }
        @keyframes pop { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        /* åŠ è½½å±‚ */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 40px; border-radius: 20px; border: 2px solid rgba(255,255,255,0.5);
            pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 30px rgba(186, 85, 211, 0.6);
            z-index: 50;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="target-bar">
    ğŸ¯ ç›®æ ‡: <span id="current-target-text">...</span>
</div>

<div id="ui-layer">
    <div id="score-board">âœ¨ å¾—åˆ†: <span id="score-val">0</span></div>
    
    <div id="top-right-panel">
        <div id="progress-board">ğŸ† è¿›åº¦: <span id="progress-text">0 / 0</span></div>
        <button id="pause-btn" class="control-btn" onclick="togglePause()">â¸ï¸ æš‚åœ</button>
        <button id="home-btn" class="control-btn" onclick="goHome()">ğŸ  ä¸»é¡µ</button>
        <!-- æ–¹ä¾¿ä½ é¢„è§ˆçš„æŒ‰é’® -->
        <button id="debug-btn" class="control-btn" onclick="showVictory()">âš¡ æµ‹è¯•é€šå…³</button>
    </div>
</div>

<div id="menu-layer">
    <div class="menu-title">ğŸŒŸ è‹±è¯­å•è¯å¤§å†’é™© ğŸŒŸ</div>
    <div class="mode-btn" onclick="selectMode(1)">
        ğŸ§ æ¨¡å¼ 1: å¬éŸ³è¾¨è¯
        <span class="mode-desc">çœ‹ä¸­æ–‡ + å¬è‹±æ–‡ -> é€‰è‹±æ–‡</span>
    </div>
    <div class="mode-btn" onclick="selectMode(2)">
        ğŸ“– æ¨¡å¼ 2: å•è¯é˜…è¯»
        <span class="mode-desc">çœ‹ä¸­æ–‡ (æ— å£°) -> é€‰è‹±æ–‡</span>
    </div>
    <div class="mode-btn" onclick="selectMode(3)">
        ğŸ‡¨ğŸ‡³ æ¨¡å¼ 3: è‹±æ±‰äº’è¯‘
        <span class="mode-desc">çœ‹è‹±æ–‡ + å¬è‹±æ–‡ -> é€‰ä¸­æ–‡</span>
    </div>
</div>

<div id="overlay">
    <div id="overlay-title">å¡ç‰‡å­¦ä¹ </div>
    <div id="overlay-content">...</div>
    <div id="overlay-sub">...</div>
    <div id="overlay-countdown">3</div>
</div>

<div id="loading" onclick="initSystem()">
    ğŸš€ ç‚¹å‡»å¼€å¯é­”æ³•å¼•æ“<br>
    <span style="font-size:16px; opacity:0.8; display:block; margin-top:10px;">(éœ€è¦éº¦å…‹é£/æ‘„åƒå¤´æƒé™)</span>
</div>

<video id="input_video" autoplay playsinline></video>
<canvas id="output_canvas"></canvas>

<script>
    // --- 1. æ ¸å¿ƒæ•°æ® ---
    const rawVocabList = [
        { cn: "é©¬ ğŸ", en: "horse" },
        { cn: "æ¯é¸¡ ğŸ”", en: "hen" },
        { cn: "èœœèœ‚ ğŸ", en: "bee" },
        { cn: "æ¸©æš–çš„ â˜€ï¸", en: "warm" },
        { cn: "èˆ’é€‚çš„ ğŸ›‹ï¸", en: "cozy" },
        { cn: "åœ†åœ†çš„ â­•", en: "round" },
        { cn: "è½¯è½¯çš„ â˜ï¸", en: "soft" },
        { cn: "å°å°çš„ ğŸœ", en: "small" },
        { cn: "å¯çˆ±çš„ ğŸ§¸", en: "cute" }
    ];

    const REPEAT_COUNT = 2; 
    const TOTAL_TASKS = rawVocabList.length * REPEAT_COUNT;
    let vocabCounts = []; 
    let currentMode = 1; 
    let levelStartTime = 0;
    
    // çƒŸèŠ±å®šæ—¶å™¨å¼•ç”¨
    let fireworkInterval = null;

    // --- 2. DOM ---
    const canvas = document.getElementById('output_canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score-val');
    const progressText = document.getElementById('progress-text');
    const loadingEl = document.getElementById('loading');
    const menuLayer = document.getElementById('menu-layer');
    const overlay = document.getElementById('overlay');
    const overlayContent = document.getElementById('overlay-content');
    const overlaySub = document.getElementById('overlay-sub');
    const overlayCountdown = document.getElementById('overlay-countdown');
    const overlayTitle = document.getElementById('overlay-title');
    const targetBar = document.getElementById('target-bar');
    const currentTargetTextEl = document.getElementById('current-target-text');
    const pauseBtn = document.getElementById('pause-btn');

    let width, height;
    let score = 0;
    let isPaused = false;
    let gameState = "IDLE"; 
    let currentVocab = null;
    let currentVocabIndex = -1;
    let lastVocabIndex = -1;
    let audioCtx = null;

    // --- 3. è¯­éŸ³ ---
    function speakWord(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel(); 
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'en-US'; u.rate = 0.8; 
            window.speechSynthesis.speak(u);
        }
    }

    // --- 4. éŸ³æ•ˆ ---
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        if (type === 'correct') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(523, now); osc.frequency.setValueAtTime(784, now + 0.1); 
            gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
            osc.start(now); osc.stop(now + 0.6);
        } else if (type === 'wrong') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(80, now + 0.3);
            gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'victory') {
            // èƒœåˆ©é•¿éŸ³
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(400, now); 
            osc.frequency.linearRampToValueAtTime(800, now+0.2);
            osc.frequency.linearRampToValueAtTime(1200, now+0.4);
            gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
            osc.start(now); osc.stop(now + 1.2);
        }
    }

    // --- 5. æµç¨‹æ§åˆ¶ ---

    function initSystem() {
        loadingEl.style.display = 'none';
        initAudio();
        camera.start();
        showMenu();
    }

    function showMenu() {
        gameState = "MENU";
        clearInterval(fireworkInterval); // åœæ­¢çƒŸèŠ±
        menuLayer.style.display = 'flex';
        overlay.style.display = 'none';
        targetBar.style.display = 'none';
        bubbles = []; particles = []; floatTexts = [];
    }

    function goHome() {
        isPaused = false;
        window.speechSynthesis.cancel();
        showMenu();
    }

    function selectMode(mode) {
        currentMode = mode;
        menuLayer.style.display = 'none';
        vocabCounts = new Array(rawVocabList.length).fill(REPEAT_COUNT);
        score = 0; scoreEl.innerText = score;
        lastVocabIndex = -1;
        nextLevel();
    }

    function nextLevel() {
        let activeIndices = [];
        let remainingTasks = 0;
        for(let i=0; i<vocabCounts.length; i++) {
            remainingTasks += vocabCounts[i];
            if (vocabCounts[i] > 0) activeIndices.push(i);
        }
        
        let completed = TOTAL_TASKS - remainingTasks;
        progressText.innerText = `${completed} / ${TOTAL_TASKS}`;

        if (remainingTasks <= 0) {
            showVictory();
            return;
        }

        let candidates = activeIndices;
        if (activeIndices.length > 1 && lastVocabIndex !== -1) {
            candidates = activeIndices.filter(idx => idx !== lastVocabIndex);
        }
        
        const selectedIndex = candidates[Math.floor(Math.random() * candidates.length)];
        currentVocabIndex = selectedIndex;
        lastVocabIndex = selectedIndex;
        currentVocab = rawVocabList[selectedIndex];

        bubbles = [];
        startTeaching();
    }

    function startTeaching() {
        gameState = "TEACHING";
        isPaused = true;
        
        overlay.style.display = 'flex';
        overlayTitle.style.display = 'block';
        overlaySub.style.display = 'block';
        overlayCountdown.style.display = 'none';
        targetBar.style.display = 'none';
        
        // é‡ç½®æ ·å¼é¿å…æ®‹ç•™
        overlayContent.className = '';
        overlaySub.className = '';
        
        if (currentMode === 1) {
            overlayTitle.innerText = "Mode 1: å¬éŸ³è¾¨è¯";
            overlayContent.innerText = currentVocab.cn;
            overlaySub.innerText = "ğŸ‘‚ ç«–èµ·è€³æœµå¬è‹±æ–‡...";
            setTimeout(() => speakWord(currentVocab.en), 200);
            setTimeout(() => speakWord(currentVocab.en), 2200);
            setTimeout(startCountdown, 4000);
        } else if (currentMode === 2) {
            overlayTitle.innerText = "Mode 2: å•è¯é˜…è¯»";
            overlayContent.innerText = currentVocab.cn;
            overlaySub.innerText = "ğŸ¤« ä»”ç»†çœ‹ï¼Œä¸è¦å‡ºå£°...";
            setTimeout(startCountdown, 3000);
        } else if (currentMode === 3) {
            overlayTitle.innerText = "Mode 3: è‹±æ±‰äº’è¯‘";
            overlayContent.innerText = currentVocab.en;
            overlaySub.innerText = "ğŸ§  å®ƒçš„ä¸­æ–‡æ„æ€æ˜¯ï¼Ÿ";
            setTimeout(() => speakWord(currentVocab.en), 200);
            setTimeout(() => speakWord(currentVocab.en), 2200);
            setTimeout(startCountdown, 4000);
        }
    }

    function startCountdown() {
        gameState = "COUNTDOWN";
        overlayTitle.style.display = 'none';
        overlayContent.style.display = 'none';
        overlaySub.style.display = 'none';
        overlayCountdown.style.display = 'block';
        
        let count = 3;
        overlayCountdown.innerText = count;
        
        const timer = setInterval(() => {
            count--;
            if (count > 0) {
                overlayCountdown.innerText = count;
            } else {
                clearInterval(timer);
                startGameplay();
            }
        }, 1000);
    }

    function startGameplay() {
        gameState = "PLAYING";
        isPaused = false;
        overlay.style.display = 'none';
        targetBar.style.display = 'block';
        levelStartTime = Date.now();
        
        if (currentMode === 1) currentTargetTextEl.innerText = `[${currentVocab.cn}] å¯¹åº”çš„è‹±æ–‡æ˜¯?`;
        else if (currentMode === 2) currentTargetTextEl.innerText = `[${currentVocab.cn}] å¯¹åº”çš„è‹±æ–‡æ˜¯?`;
        else if (currentMode === 3) currentTargetTextEl.innerText = `[${currentVocab.en}] å¯¹åº”çš„ä¸­æ–‡æ˜¯?`;
    }

    // --- æ ¸å¿ƒä¿®å¤ï¼šé€šå…³å±•ç¤º ---
    function showVictory() {
        gameState = "VICTORY";
        isPaused = false; // å…³é”®ï¼šä¸æš‚åœï¼Œè®©ç²’å­ç»§ç»­æ¸²æŸ“
        
        bubbles = []; // æ¸…ç©ºæ°”æ³¡
        
        overlay.style.display = 'flex';
        overlayTitle.innerText = "ğŸ‰ æŒ‘æˆ˜æˆåŠŸï¼ ğŸ‰";
        overlayTitle.style.display = 'block';
        
        overlayContent.innerText = "YOU WIN!";
        overlayContent.style.display = 'block';
        overlayContent.className = 'victory-title'; // åº”ç”¨å¤§å·éœ“è™¹æ ·å¼
        
        overlaySub.innerText = "ğŸ  è¿”å›ä¸»èœå•";
        overlaySub.style.display = 'block';
        overlaySub.className = 'victory-sub';
        overlaySub.onclick = () => goHome();
        
        overlayCountdown.style.display = 'none';
        targetBar.style.display = 'none';
        
        // å¯åŠ¨å½©è‰²çƒŸèŠ±å¾ªç¯
        clearInterval(fireworkInterval);
        fireworkInterval = setInterval(() => {
             if (gameState !== "VICTORY") {
                 clearInterval(fireworkInterval);
                 return;
             }
             playSound('victory');
             // æ¯æ¬¡å‘å°„ 8-10 ä¸ªå½©è‰²ç²’å­
             for(let i=0; i<10; i++) {
                 // åœ¨å±å¹•ä¸­é—´éšæœºä½ç½®çˆ†ç‚¸
                 const px = width/2 + (Math.random()-0.5)*800;
                 const py = height/2 + (Math.random()-0.5)*500;
                 particles.push(new Particle(px, py, 'victory'));
             }
        }, 500);
    }

    function togglePause() {
        if (gameState !== "PLAYING") return;
        isPaused = !isPaused;
        pauseBtn.innerText = isPaused ? "â–¶ï¸ ç»§ç»­" : "â¸ï¸ æš‚åœ";
    }

    // --- 6. è§†è§‰å¯¹è±¡ ---
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        initStars();
    }
    window.addEventListener('resize', resize);

    let bgStars = [];
    class BgStar {
        constructor() {
            this.x = Math.random() * width; this.y = Math.random() * height;
            this.size = Math.random() * 2 + 0.5; this.alpha = Math.random(); this.blinkDir = 0.02;
        }
        update() { this.alpha += this.blinkDir; if (this.alpha > 1 || this.alpha < 0.2) this.blinkDir *= -1; }
        draw() { ctx.fillStyle = `rgba(255,255,255,${this.alpha})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
    }
    function initStars() { bgStars = []; for(let i=0; i<80; i++) bgStars.push(new BgStar()); }

    class Bubble {
        constructor(text, isCorrect) {
            this.r = 65; this.y = height + 80;
            this.text = text; this.isCorrect = isCorrect;
            this.speed = (Math.random() * 1.5 + 1) * 0.5;
            let safeX = -1, attempts = 0;
            while (safeX < 0 && attempts < 10) {
                let testX = Math.random() * (width - 150) + 75;
                if (!bubbles.some(b => Math.abs(b.x - testX) < 140)) safeX = testX;
                attempts++;
            }
            this.x = safeX > 0 ? safeX : Math.random() * (width - 150) + 75;
            this.hue = Math.random() * 360;
            this.color = `hsla(${this.hue}, 80%, 70%, 0.3)`;
            this.stroke = `hsla(${this.hue}, 100%, 85%, 1)`;
            this.wobble = Math.random() * Math.PI * 2;
        }
        update() { this.y -= this.speed; this.x += Math.sin(this.wobble) * 0.5; this.wobble += 0.02; }
        draw() {
            ctx.beginPath(); ctx.fillStyle = this.color; ctx.strokeStyle = this.stroke; ctx.lineWidth = 4;
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.font = (currentMode === 3) ? "bold 50px 'Microsoft YaHei'" : "bold 36px Comic Sans MS";
            ctx.fillText(this.text, this.x, this.y);
        }
    }

    class Particle {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 6 + 2;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.life = 1.0; this.type = type; 
            
            if (type === 'gold') {
                this.color = `hsl(${45 + Math.random()*15}, 100%, 60%)`; 
                this.gravity = 0.15; this.decay = 0.015; this.size = Math.random() * 7 + 4;
            } else if (type === 'victory') {
                // å½©è‰²çƒŸèŠ±
                this.color = `hsl(${Math.random() * 360}, 100%, 60%)`;
                this.gravity = 0.1; this.decay = 0.01; this.size = Math.random() * 8 + 5;
            } else {
                this.color = `rgba(50, 50, 50, 1)`; 
                this.gravity = -0.05; this.decay = 0.04; this.size = Math.random() * 5 + 2;
            }
        }
        update() {
            this.vx *= 0.95; this.vy *= 0.95; this.vy += this.gravity;
            this.x += this.vx; this.y += this.vy; this.life -= this.decay;
        }
        draw() {
            ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class FloatText {
        constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 1.0; }
        update() { this.y -= 1; this.life -= 0.02; }
        draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.font = "bold 40px Arial"; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0; }
    }
    class Trail {
        constructor(x, y) { this.x = x; this.y = y; this.life = 1.0; }
        update() { this.life -= 0.1; }
        draw() { ctx.fillStyle = `rgba(255,255,255,${this.life})`; ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill(); }
    }

    // --- 7. ä¸»å¾ªç¯ ---
    let handX = -100, handY = -100;
    let bubbles = [], particles = [], trails = [], floatTexts = [];
    let frameCount = 0;

    resize();
    initStars();

    function gameLoop() {
        ctx.clearRect(0, 0, width, height);
        bgStars.forEach(s => { s.update(); s.draw(); });

        // æ— è®ºæ˜¯ PLAYING è¿˜æ˜¯ VICTORYï¼Œéƒ½è¦æ›´æ–°ç²’å­ç‰¹æ•ˆï¼Œå¦åˆ™çƒŸèŠ±ä¼šé™æ­¢
        [particles, trails, floatTexts].forEach(arr => {
            for(let i=arr.length-1; i>=0; i--) {
                arr[i].update(); arr[i].draw();
                if(arr[i].life <= 0) arr.splice(i, 1);
            }
        });

        if (gameState === "PLAYING" && !isPaused) {
            frameCount++;
            if (frameCount % 180 === 0 && bubbles.length < 3) {
                const timeElapsed = Date.now() - levelStartTime;
                let forceWrong = (timeElapsed < 3000); 
                const hasCorrectOnScreen = bubbles.some(b => b.isCorrect);
                let willSpawnCorrect = (!forceWrong && !hasCorrectOnScreen) && (Math.random() < 0.6);

                let bubbleText = "", isCorrect = false;
                if (willSpawnCorrect) {
                    bubbleText = (currentMode === 3) ? currentVocab.cn : currentVocab.en;
                    isCorrect = true;
                } else {
                    let randomWrong;
                    do { randomWrong = rawVocabList[Math.floor(Math.random() * rawVocabList.length)]; } while (randomWrong.en === currentVocab.en);
                    bubbleText = (currentMode === 3) ? randomWrong.cn : randomWrong.en;
                    isCorrect = false;
                }
                if (!bubbles.some(b => b.text === bubbleText)) bubbles.push(new Bubble(bubbleText, isCorrect));
            }

            for (let i = bubbles.length - 1; i >= 0; i--) {
                let b = bubbles[i];
                b.update(); b.draw();
                const dx = handX - b.x, dy = handY - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.r + 15) {
                    if (b.isCorrect) {
                        playSound('correct');
                        score += 10; scoreEl.innerText = score;
                        if(vocabCounts[currentVocabIndex] > 0) vocabCounts[currentVocabIndex]--;
                        for(let k=0; k<40; k++) particles.push(new Particle(b.x, b.y, 'gold'));
                        floatTexts.push(new FloatText(b.x, b.y, "Bingo! +10", "#ffd700"));
                        bubbles.splice(i, 1);
                        gameState = "WAITING";
                        setTimeout(nextLevel, 1500);
                    } else {
                        playSound('wrong');
                        for(let k=0; k<15; k++) particles.push(new Particle(b.x, b.y, 'dark'));
                        floatTexts.push(new FloatText(b.x, b.y, "Try Again", "#aaa"));
                        bubbles.splice(i, 1);
                    }
                } else if (b.y < -100) bubbles.splice(i, 1);
            }
        }

        if (handX > 0 && gameState !== "MENU") {
            trails.push(new Trail(handX, handY));
            ctx.beginPath(); ctx.fillStyle = "#fff";
            ctx.shadowBlur = 15; ctx.shadowColor = "#0ff";
            ctx.arc(handX, handY, 12, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        }

        requestAnimationFrame(gameLoop);
    }
    gameLoop();

    const videoElement = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const p = results.multiHandLandmarks[0][8];
            const tx = (1 - p.x) * width, ty = p.y * height;
            if (handX < 0) { handX = tx; handY = ty; }
            else { handX += (tx - handX) * 0.3; handY += (ty - handY) * 0.3; }
        }
    });
    const camera = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480 });
    window.addEventListener('mousemove', e => { if (!isPaused) { handX = e.clientX; handY = e.clientY; } });
</script>
</body>
</html>
